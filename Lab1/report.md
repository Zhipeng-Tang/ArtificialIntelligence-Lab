# report

PB19111690 唐志鹏

## 1 dight

### 1.1 算法思想

1. 初始化状态和`open_list`（优先队列，$f(n)=g(n)+h(n)$最小者在队头）

2. 取出`open_list`的队头元素`curr`：

   若`curr == target`，则找到目标，返回结果

   若`curr != target`，则向上下左右四个方向试探，并将新的四个状态加入`open_list`（某方向遇到黑洞或边界则该方向不能产生新状态），继续步骤 2

### 1.2 启发函数

在忽略黑洞和所有其它星球的情况下，计算每个星球回到目标位置的最短步数$d$（在没有星际通道的情况下最短步数就是曼哈顿距离：$|x_1-x_2|+|y_1-y_2|$，$(x_1,y_1)$是星球位置，$(x_2,y_2)$是星球目标位置），那么显然启发函数$h(n)=\sum{d}$是可采纳的

由于考虑星际通道时$d$的计算十分复杂，所以这里退而求其次，取$d'=min\{|x_1-x_2|, 5-|x_1-x_2|\}+min\{|y_1-y_2|, 5-|y_1-y_2|\}$，显然有$d'\leq d$

取启发函数$h_2(n)=\sum{d'} \leq \sum d = h(n)$

由$h(n)$可采纳知，$h_2(n)$也是可采纳的

### 1.3 运行结果

| 样例编号 | 移动序列                                                     | 总步数 | A_h1运行时间 | A_h2运行时间 | IDA_h1运行时间 | IDA_h2运行时间 |
| -------- | ------------------------------------------------------------ | ------ | ------------ | ------------ | -------------- | -------------- |
| 00       | DDRUR                                                        | 5      | 0.000s       | 0.000s       | 0.001s         | 0.000s         |
| 01       | ULLUULDD                                                     | 8      | 0.000s       | 0.001s       | 0.000s         | 0.000s         |
| 02       | DDLUULLURR                                                   | 10     | 0.001s       | 0.000s       | 0.000s         | 0.000s         |
| 03       | DLDRRURRRUUURR                                               | 14     | 0.001s       | 0.000s       | 0.000s         | 0.000s         |
| 04       | LUUURULLURDDRDR                                              | 15     | 0.009s       | 0.001s       | 0.007s         | 0.000s         |
| 05       | LLUURRRUURDDDDLUURDD                                         | 20     | 0.024s       | 0.000s       | 0.018s         | 0.000s         |
| 06       | DRDLLULULUUURDRURDRDRRR                                      | 23     | 0.036s       | 0.005s       | 0.027s         | 0.005s         |
| 07       | URRRRDLLLLDRRRRDLLLLDRRRR                                    | 25     | 0.001s       | 0.001s       | 0.001s         | 0.001s         |
| 08       | h1:DLLLDRUUUULDRRRRULDDDDRULDR<br>h2:DDRULLLLDRUUUULDRRRRULDDDDR | 27     | 0.815s       | 0.003s       | 0.696s         | 0.004s         |
| 09       | h1:RDRDLUUUURRDRDDRUUULLDRULURR<br>h2:RRRRDRUUULDLDLLDRDLUUUURRURR | 28     | 23.392s      | 1.191s       | 22.651s        | 1.175s         |
| 10       | DDRRUUUULLULLUULLLLLUURRDDDDRR                               | 30     | 1.218s       | 0.002s       | 1.984s         | 0.001s         |
| 11       | DRUURDRRDRUULDLULDLDRDLDRURDRURD                             | 32     | x            | 0.179s       | x              | 0.189s         |

- 通过对比可以发现启发函数$h_2(n)$的效果显著好于启发函数$h_1(n)$

### 1.4 优化

#### 1.4.1 控制飞船不往回走

- 对比优化前后的运行时间：

  | 样例编号 | 优化前A_h1运行时间 | 优化后A_h1运行时间 | 优化前A_h2运行时间 | 优化后A_h2运行时间 | 优化前IDA_h1运行时间 | 优化后IDA_h1运行时间 | 优化前IDA_h2运行时间 | 优化后IDA_h2运行时间 |
  | -------- | ------------------ | ------------------ | ------------------ | ------------------ | -------------------- | -------------------- | -------------------- | -------------------- |
  | 00       | 0.000s             | 0.000s             | 0.000s             | 0.001s             | 0.001s               | 0.001s               | 0.000s               | 0.000s               |
  | 01       | 0.000s             | 0.000s             | 0.001s             | 0.000s             | 0.000s               | 0.000s               | 0.000s               | 0.000s               |
  | 02       | 0.001s             | 0.001s             | 0.000s             | 0.000s             | 0.000s               | 0.001s               | 0.000s               | 0.000s               |
  | 03       | 0.001s             | 0.001s             | 0.000s             | 0.000s             | 0.000s               | 0.000s               | 0.000s               | 0.001s               |
  | 04       | 0.009s             | 0.001s             | 0.001s             | 0.001s             | 0.007s               | 0.002s               | 0.000s               | 0.000s               |
  | 05       | 0.024s             | 0.001s             | 0.000s             | 0.000s             | 0.018s               | 0.002s               | 0.000s               | 0.001s               |
  | 06       | 0.036s             | 0.003s             | 0.005s             | 0.002s             | 0.027s               | 0.005s               | 0.005s               | 0.001s               |
  | 07       | 0.001s             | 0.000s             | 0.001s             | 0.000s             | 0.001s               | 0.000s               | 0.001s               | 0.001s               |
  | 08       | 0.815s             | 0.015s             | 0.003s             | 0.005s             | 0.696s               | 0.028s               | 0.004s               | 0.005s               |
  | 09       | 23.392s            | 0.198s             | 1.191s             | 0.029s             | 22.651s              | 0.334s               | 1.175s               | 0.051s               |
  | 10       | 1.218s             | 0.010s             | 0.002s             | 0.000s             | 1.984s               | 0.022s               | 0.001s               | 0.000s               |
  | 11       | x                  | 0.771s             | 0.179s             | 0.014s             | x                    | 1.260s               | 0.189s               | 0.028s               |

- 通过对比可以发现，在控制飞船不往回走后，性能大概提升了$40到100$倍
- 可以进一步记录到达过的状态，控制运行过程中不要到达这些重复状态

## 2 CSP

### 2.1 变量集合

这里以有$N$名工人，每天至少要有$M$个人值班，有$k$个 senior 级别工人，分别为$a_1,a_2,...a_k$来说明

- 变量集合为一个$N \times 7$个`bool`值，可以理解为一个$N \times 7$的表
- 值域集合：每个变量取值集合为$\{\text{true, false}\}$，比如，变量$(3,1)$取值为$\text{true}$表示工人$3$周一要上班
- 约束集合：
  - 每个工人每周必须休息2天或2天以上：$(i,1),(i,2),...,(i,7),\ 1 \leq i \leq N\ $这$7$个变量中至少有$2$个取值为$\text{false}$
  -  每个工人每周不可以连续休息3天：$(i,j+1),(i,j+2),(i,j+1),\ 1 \leq i \leq N,\ 0\leq j \leq 4\ $这$3$个变量不能同时取$\text{false}$
  - 每天至少要有$M$个人值班：$(1,j),(2,j),...,(N,j),\ 1 \leq j \leq 7\ $这$N$个变量中至少有$M$个取值为$\text{true}$
  - 每天至少要有一名级别为 senior 的工人值班：$(a_1,j),(a_2,j),...,(a_k,j),\ 1 \leq j \leq 7\ $这$k$个变量中至少有$1$个取值为$\text{true}$
  - 工人$S$不想和工人$T$一起工作：$(S,j),(T,j),\ 1 \leq j \leq 7\ $这$2$个变量不能同时取$\text{true}$

### 2.2 算法的主要思路

主要采用 backtracking_search 算法：

```c++
bool backtracking_search(assignment, csp)
    if assignment is complete
        retrun true						// 如果该赋值已经满足要求，则返回true
    if every variable is asigned
        return false					// 如果所有变量被复制，但不满足，则返回false
    var = the next variable to be assigned	// var 是下一个将要被赋值的变量
    for each value of var					// 对于 var 可取的每一个值 value
        assignment = {assignment + {var = value}
        if assignment is consistent	// 如果没有矛盾， 则递归执行
            if (backtracking_search({assignment, var = value}, csp) == true)
                return true
        else
            assignment = assignment - {var = value} // 否则，回退
```

### 2.3 优化

#### 2.3.1 MRV启发式

- 用`remaining_value`维护每个变量的剩余值，每次挑选下一个将要被赋值的变量时，挑选剩余值最少的变量
- 注意：回退后，需要将变量的剩余值恢复至初始状态

#### 2.3.2 前向检验

- 在确定某些变量值得同时，另一些变量可选取的值的范围会变小，通过`remaining_value`维护每个变量的剩余值
- 若某个变量的没有剩余值，则直接回退

#### 2.3.3 约束传播

- 一些变量的值被确定之后会进一步通过其它约束影响其他变量
- 可以一直传播约束，**直到没有变量的剩余值改变**

#### 2.3.4 优化效果

- 这是加入MRV启发式、前向检验和约束传播优化和没有优化的性能对比

- 记录优化前后的运行时间和变量赋值次数：

  | 样例（工人数） | 优化前运行时间 | 优化后运行时间 | $\frac{优化前运行时间}{优化后运行时间}$ | 优化前赋值次数 | 优化后赋值次数 | $\frac{优化前赋值次数}{优化后赋值次数}$ |
  | -------------- | -------------- | -------------- | --------------------------------------- | -------------- | -------------- | --------------------------------------- |
  | 5              | 0.164s         | 0.063s         | 2.603                                   | 140            | 38             | 3.684                                   |
  | 7              | 0.645s         | 0.138s         | 4.674                                   | 323            | 45             | 7.178                                   |
  | 10             | 0.680s         | 0.407s         | 1.671                                   | 225            | 97             | 2.320                                   |

- 可以发现优化后变量赋值次数显著减少

- 由于优化本身的开销，运行时间提高的倍数比赋值次数提高的倍数要低

### 2.4 模拟退火算法

```c++
void simulated_annealing(assignment, csp)
    // assignment 是一个初始赋值，csp 说所有的约束的集合
    current = assignment
    for t 1 to ∞
        // schedule is a mapping from time to "temperature"
        T = schedule[t]
        if T = 0 return
        next = a randomly selected successor
        
        // 这里的 value 取为当前赋值不满足的约束的个数
        ΔE = value[current] - value[next]
        
        if ΔE > 0 currenr = next
        else current = next only with probablity e^{ΔE/T}
```

